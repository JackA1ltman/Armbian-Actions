// SPDX-License-Identifier: (GPL-2.0+ OR MIT)

/dts-v1/; // Device Tree Source 版本声明

// 包含其他 Device Tree 文件
#include <dt-bindings/usb/pd.h>                  // USB Power Delivery 相关绑定
#include <dt-bindings/gpio/gpio.h>               // GPIO 相关绑定
#include <dt-bindings/pwm/pwm.h>                 // PWM 相关绑定
#include <dt-bindings/pinctrl/rockchip.h>        // Rockchip Pinctrl 相关绑定
#include <dt-bindings/input/linux-event-codes.h> // Linux 输入事件码绑定
#include <dt-bindings/display/drm_mipi_dsi.h>    // MIPI DSI 显示相关绑定
#include <dt-bindings/display/rockchip_vop.h>    // Rockchip VOP 显示相关绑定
#include <dt-bindings/phy/jlsemi-dt-phy.h>       // JLsemi PHY 相关绑定 (劲龙微电子)
#include <dt-bindings/sensor-dev.h>              // 传感器设备相关绑定
#include "rk3588.dtsi"                           // 包含 RK3588 SoC 基础定义
#include "rk3588-linux.dtsi"                     // 包含 RK3588 Linux 特定的定义

/ { // 根节点
	model = "LemonPi Pi 1"; // 开发板型号
	compatible = "lemonpi,lemonpi-pi1", "rockchip,rk3588"; // 兼容性列表，用于内核匹配驱动

	chosen: chosen { // 内核启动时选择的参数
		bootargs = "earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 irqchip.gicv3_pseudo_nmi=0 rcupdate.rcu_expedited=1 rcu_nocbs=all"; // 内核启动参数
		// earlycon: 早期控制台，用于在完整控制台驱动加载前输出信息 (UART2)
		// console=ttyFIQ0: 指定 FIQ Debug UART 作为主控制台
		// irqchip.gicv3_pseudo_nmi=0: 禁用 GICv3 伪 NMI
		// rcupdate.rcu_expedited=1: 加速 RCU 宽限期
		// rcu_nocbs=all: 将 RCU 回调卸载到 kthreads，减轻 CPU 负担
	};

	/* 如果 hdmirx 节点被禁用，请删除此处的 reserved-memory 节点 */
	reserved-memory { // 预留内存区域
		#address-cells = <2>; // 地址字段的 cell 数量 (64位地址)
		#size-cells = <2>;    // 大小字段的 cell 数量 (64位大小)
		ranges;               // 定义地址映射范围 (此处为空，表示直接使用父节点地址空间)
		/* 为 hdmirx-controller@fdee0000 预留 256MB 内存 */
		cma { // Contiguous Memory Allocator (连续内存分配器) 区域
			compatible = "shared-dma-pool"; // 兼容性字符串，表明是共享 DMA 池
			reusable;                       // 表明此区域内存可被回收复用
			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>; // 定义预留区域的基地址和大小 (这里定义了两次，可能是笔误或特定用法，通常定义一次)
			// 实际地址和大小可能由 bootloader 或内核参数决定，这里更像是一个占位符或最大范围
			linux,cma-default;              // 标记为 Linux 内核的默认 CMA 区域
		};
	};

	adc_keys: adc-keys { // ADC 按键节点
		compatible = "adc-keys";         // 兼容性字符串
		io-channels = <&saradc 1>;       // 使用 SARADC 的通道 1
		io-channel-names = "buttons";    // IO 通道名称
		keyup-threshold-microvolt = <1800000>; // 按键抬起电压阈值 (1.8V)
		poll-interval = <100>;           // 轮询间隔 (100ms)

		power { // 电源按键定义
			label = "power";                   // 按键标签
			linux,code = <KEY_POWER>;          // Linux 输入事件码 (电源键)
			press-threshold-microvolt = <1750>; // 按键按下电压阈值 (约 0.00175V，可能需要根据实际电路调整)
		};
	};

	leds: leds { // LED 灯节点
		status = "okay";          // 使能该节点
		compatible = "gpio-leds"; // 兼容性字符串

		sys_led: sys-led { // 系统状态 LED
			label = "sys_led";                      // LED 标签
			linux,default-trigger = "heartbeat";    // 默认触发器 (心跳)
			default-state = "on";                   // 默认状态 (亮)
			gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_LOW>; // 使用 GPIO0_D3，低电平有效
			pinctrl-names = "default";              // pinctrl 状态名称
			pinctrl-0 = <&sys_led_pin>;             // 对应的 pinctrl 配置
		};

		abc_led: abc-led { // 示例 LED abc
			label = "abc_led";
			linux,default-trigger = "heartbeat";
			default-state = "on";
			gpios = <&gpio6 0 GPIO_ACTIVE_HIGH>; // 使用 GPIO 扩展器 gpio6 的第 0 个引脚，高电平有效
		};

		def_led: def-led { // 示例 LED def
			label = "def_led";
			linux,default-trigger = "heartbeat";
			default-state = "on";
			gpios = <&gpio7 2 GPIO_ACTIVE_HIGH>; // 使用 GPIO 扩展器 gpio7 的第 2 个引脚，高电平有效
		};
	};

	// --- 电源稳压器 (Regulator) 定义 ---
	// 这些节点描述了开发板上的电源树，定义了各种电压轨及其来源

	vcc12v_dcin: vcc12v-dcin { // 12V DC 输入
		compatible = "regulator-fixed";   // 固定电压稳压器
		regulator-always-on;              // 系统运行时始终开启
		regulator-boot-on;                // 引导时即开启
		regulator-min-microvolt = <12000000>; // 最小电压 (12V)
		regulator-max-microvolt = <12000000>; // 最大电压 (12V)
		regulator-name = "vcc12v_dcin";   // 稳压器名称
	};

	vcc5v0_sys: vcc5v0-sys { // 系统 5V 电源
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_sys";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <5000000>; // 5V
		regulator-max-microvolt = <5000000>; // 5V
		vin-supply = <&vcc12v_dcin>;        // 输入源是 12V DC
	};

	vcc3v3_sys: vcc3v3-sys { // 系统 3.3V 电源
		compatible = "regulator-fixed";
		regulator-name = "vcc3v3_sys";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <3300000>; // 3.3V
		regulator-max-microvolt = <3300000>; // 3.3V
		vin-supply = <&vcc12v_dcin>;        // 输入源是 12V DC (或板上其他转换器)
	};

	vcc_5v0: vcc-5v0 { // 另一个 5V 电源轨 (可能用于特定外设)
		compatible = "regulator-fixed";
		regulator-name = "vcc_5v0";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <5000000>; // 5V
		regulator-max-microvolt = <5000000>; // 5V
		vin-supply = <&vcc5v0_sys>;         // 输入源是 系统 5V
	};

	vcc5v0_usb: vcc5v0-usb { // USB 5V 电源
		compatible = "regulator-fixed";
		regulator-name = "vcc5v0_usb"; // 名称似乎有误，应与 vcc_5v0 区分或修正
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <5000000>; // 5V
		regulator-max-microvolt = <5000000>; // 5V
		vin-supply = <&vcc5v0_sys>;         // 输入源是 系统 5V
	};

	combophy_avdd1v8: combophy-avdd1v8 { // Combo PHY AVDD 1.8V
		compatible = "regulator-fixed";
		regulator-name = "combophy_avdd1v8";
		regulator-boot-on;
		regulator-min-microvolt = <1800000>; // 1.8V
		regulator-max-microvolt = <1800000>; // 1.8V
		vin-supply = <&avcc_1v8_s0>;        // 输入源是 avcc_1v8_s0 (来自 PMIC)
	};

	// 注意：以下几个 S3 状态的电源定义可能与 RK806 PMIC 的 LDO/DCDC 输出有关联
	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 { // 1.1V NLDO (可能用于待机状态 S3)
		compatible = "regulator-fixed";
		regulator-name = "vcc_1v1_nldo_s3";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <1100000>; // 1.1V
		regulator-max-microvolt = <1100000>; // 1.1V
		vin-supply = <&vcc5v0_sys>;         // 输入源是 系统 5V (这看起来有点奇怪，通常 LDO 输入电压不会这么高，可能描述的是更上游的来源或简化了)
	};

	vcc_3v3_s0: vcc-3v3-s0 { // 工作状态 S0 的 3.3V
		compatible = "regulator-fixed";
		regulator-name = "vcc_3v3_s0";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <3300000>; // 3.3V
		regulator-max-microvolt = <3300000>; // 3.3V
		vin-supply = <&vcc_3v3_s3>;         // 输入源是 vcc_3v3_s3 (来自 PMIC DCDC_REG8)
	};

	vcc_3v3_sd_s3: vcc-3v3-sd-s3 { // SD 卡接口的 3.3V (待机 S3 状态也可能保持供电)
		compatible = "regulator-fixed";
		regulator-name = "vcc_3v3_sd_s3";
		regulator-always-on;
		regulator-boot-on;
		regulator-min-microvolt = <3300000>; // 3.3V
		regulator-max-microvolt = <3300000>; // 3.3V
		vin-supply = <&vcc_3v3_s3>;         // 输入源是 vcc_3v3_s3 (来自 PMIC DCDC_REG8)
	};

	vbus_typec: vbus-typec { // Type-C VBUS 控制
		compatible = "regulator-fixed";     // 固定电压 (但实际由 GPIO 控制开关)
		regulator-name = "vbus_typec";
		regulator-min-microvolt = <5000000>; // 5V
		regulator-max-microvolt = <5000000>; // 5V
		enable-active-high;                 // 高电平使能
		gpio = <&gpio2 RK_PB5 GPIO_ACTIVE_HIGH>; // 使能 GPIO (GPIO2_B5)
		vin-supply = <&vcc5v0_usb>;         // 输入源是 USB 5V
		pinctrl-names = "default";
		pinctrl-0 = <&typec_vbus_en>;       // 对应的 pinctrl 配置
	};

	// --- 显示接口电源控制 ---
	mipi_dsi0_power: mipi-dsi0-power-regulator { // MIPI DSI0 接口电源
		compatible = "regulator-fixed";
		regulator-name = "mipi_dsi0_power";
		gpio = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>; // 使能 GPIO (GPIO1_D2)
		enable-active-high;
		regulator-boot-on;
		regulator-always-on;
	};

	mipi_dsi1_power: mipi-dsi1-power-regulator { // MIPI DSI1 接口电源
		compatible = "regulator-fixed";
		regulator-name = "mipi_dsi1_power";
		gpio = <&gpio2 RK_PB4 GPIO_ACTIVE_HIGH>; // 使能 GPIO (GPIO2_B4)
		enable-active-high;
		regulator-boot-on;
		regulator-always-on;
	};

	mipi_dp1_power: mipi-edp-power-regulator { // MIPI/DP1 接口电源 (可能是 eDP)
		compatible = "regulator-fixed";
		regulator-name = "mipi_dp1_power";
		gpio = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>; // 使能 GPIO (GPIO0_A0)
		enable-active-high;
		regulator-boot-on;
		regulator-always-on;
	};

	// --- 音频设备节点 ---
	hdmiin_sound: hdmiin-sound { // HDMI 输入音频
		compatible = "rockchip,hdmi";         // Rockchip HDMI 音频接口
		rockchip,mclk-fs = <128>;             // MCLK 与 FSYNC 的频率比 (128*Fs)
		rockchip,format = "i2s";              // 音频格式 (I2S)
		rockchip,bitclock-master = <&hdmirx_ctrler>; // Bit Clock 由 HDMI RX 控制器提供
		rockchip,frame-master = <&hdmirx_ctrler>; // Frame Clock (LRCK) 由 HDMI RX 控制器提供
		rockchip,card-name = "rockchip-hdmiin"; // ALSA 声卡名称
		rockchip,cpu = <&i2s7_8ch>;            // SoC 端的 DAI (Digital Audio Interface) CPU 部分 (I2S7)
		rockchip,codec = <&hdmirx_ctrler 0>;   // Codec 部分 (HDMI RX 控制器，索引 0)
		rockchip,jack-det;                    // 使用标准的 Jack 检测机制 (可能通过 HDMI HPD)
		status = "okay";                      // 在 hdmirx_ctrler 使能时再设置为 okay
	};

	hdmi1_sound: hdmi1-sound { // HDMI1 输出音频
		status = "okay";                      // 使能该节点
		compatible = "rockchip,hdmi";
		rockchip,mclk-fs = <128>;
		rockchip,card-name = "rockchip-hdmi1";
		rockchip,cpu = <&i2s6_8ch>;            // SoC DAI CPU (I2S6)
		rockchip,codec = <&hdmi1>;             // Codec (HDMI1 控制器)
		rockchip,jack-det;
	};

	dp0_sound: dp0-sound { // DisplayPort 0 输出音频
		status = "okay";
		compatible = "rockchip,hdmi";          // 复用 HDMI 音频驱动框架
		rockchip,card-name = "rockchip-dp0";
		rockchip,mclk-fs = <512>;              // MCLK/FS 比例 (512*Fs)
		rockchip,cpu = <&spdif_tx2>;           // SoC DAI CPU (SPDIF TX2)
		rockchip,codec = <&dp0 1>;             // Codec (DP0 控制器，索引 1)
		rockchip,jack-det;
	};

	es8388_sound: es8388-sound { // ES8388 音频 Codec 声卡定义
		status = "okay";
		compatible = "rockchip,multicodecs-card"; // Rockchip 多 Codec 声卡驱动
		rockchip,card-name = "rockchip-es8388"; // 声卡名称
		hp-det-gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>; // 耳机检测 GPIO (GPIO1_D3)，高电平表示插入
		hp-con-gpio = <&gpio1 RK_PB5 GPIO_ACTIVE_HIGH>; // 耳机连接状态 GPIO (未使用或特定功能?)
		io-channels = <&saradc 4>;             // 使用 SARADC 通道 4 检测耳机线控按键
		io-channel-names = "adc-detect";       // 通道名称
		keyup-threshold-microvolt = <1800000>; // 线控按键抬起电压阈值 (1.8V)
		poll-interval = <100>;               // 轮询间隔 (100ms)
		rockchip,format = "i2s";               // 音频格式 (I2S)
		rockchip,mclk-fs = <256>;              // MCLK/FS 比例 (256*Fs)
		rockchip,cpu = <&i2s0_8ch>;            // SoC DAI CPU (I2S0)
		rockchip,codec = <&es8388>;            // Codec (ES8388)
		rockchip,audio-routing =               // 音频路由配置
			"Headphone", "LOUT1",          // "耳机插孔" 连接到 Codec 的 "LOUT1"
			"Headphone", "ROUT1",          // "耳机插孔" 连接到 Codec 的 "ROUT1"
			"Headphone", "Headphone Power", // "耳机插孔" 连接到 Codec 的 "Headphone Power" (可能是使能)
			"Headphone", "Headphone Power", // (重复)
			"LINPUT1", "Main Mic",           // Codec 的 "LINPUT1" 连接到 "主麦克风"
			"LINPUT2", "Main Mic",           // Codec 的 "LINPUT2" 连接到 "主麦克风"
			"RINPUT1", "Headset Mic",        // Codec 的 "RINPUT1" 连接到 "耳机麦克风"
			"RINPUT2", "Headset Mic";        // Codec 的 "RINPUT2" 连接到 "耳机麦克风"
		pinctrl-names = "default";
		pinctrl-0 = <&hp_det>;                 // 耳机检测引脚的 pinctrl 配置
		// --- 耳机线控按键定义 ---
		play-pause-key {
			label = "playpause";
			linux,code = <KEY_PLAYPAUSE>;        // 播放/暂停键
			press-threshold-microvolt = <2000>; // 按下电压阈值 (0.002V)
		};
		previous-song-key {
			label = "previoussong";
			linux,code = <KEY_PREVIOUSSONG>;     // 上一曲键
			press-threshold-microvolt = <145000>; // 按下电压阈值 (0.145V)
		};
		next-song-key {
			label = "nextsong";
			linux,code = <KEY_NEXTSONG>;         // 下一曲键
			press-threshold-microvolt = <290000>; // 按下电压阈值 (0.29V)
		};
	};

	fan: pwm-fan { // PWM 风扇节点
		compatible = "pwm-fan";             // 兼容性字符串
		#cooling-cells = <2>;             // 冷却设备单元数量 (用于 thermal framework)
		pwms = <&pwm4 0 5000 0>;            // 使用 PWM4，通道 0，周期 5000ns (200kHz)，初始占空比 0，极性不反转
		cooling-levels = <0 100 150 200 255>; // 风扇速度等级 (对应 PWM 占空比 0-255)
		rockchip,temp-trips = <            // 温度触发点与风扇等级映射
			50000	1                     // 50°C -> level 1 (占空比 100/255)
			55000	2                     // 55°C -> level 2 (占空比 150/255)
			60000	3                     // 60°C -> level 3 (占空比 200/255)
			65000	4                     // 65°C -> level 4 (占空比 255/255)
		>;
		status = "okay";                   // 在 pwm4 使能时再设置为 okay
	};

	test-power { // 测试电源节点 (可能用于调试)
		status = "okay";
	};
}; // 根节点结束

// --- 以下是对 SoC 内部模块的配置和覆盖 (Overlay) ---
// 使用 "&<node_label>" 语法来引用 rk3588.dtsi 中定义的节点，并修改或添加属性

// &pwm11 { // PWM11 配置示例 (被注释掉了)
// 	pinctrl-0 = <&pwm11m1_pins>;
// 	status = "okay";
// };

&dmc_opp_table { // DDR 内存控制器操作点 (Operating Performance Point) 表
	/delete-node/ opp-2750000000; // 删除 2750 MHz 的 OPP 点 (可能此板卡不支持)
};

&av1d { // AV1 解码器
	status = "okay"; // 使能
};

&av1d_mmu { // AV1 解码器 MMU
	status = "okay"; // 使能
};

&spdif_tx2 { // SPDIF 发送器 2
	status = "okay"; // 使能 (用于 DP0 音频)
};

&i2s5_8ch { // I2S5 (8通道)
	status = "okay"; // 使能 (虽然在此 DTS 中未直接使用，可能预留或被其他include的文件使用)
};

&i2s6_8ch { // I2S6 (8通道)
	status = "okay"; // 使能 (用于 HDMI1 音频)
};

// --- CPU 核心供电配置 ---
&cpu_l0 { // LITTLE CPU 核心簇 0 (Cortex-A55)
	cpu-supply = <&vdd_cpu_lit_s0>;     // 核心电压轨 (来自 PMIC DCDC_REG2)
	mem-supply = <&vdd_cpu_lit_mem_s0>; // L2 缓存等内存相关电压轨 (与核心电压相同)
};

&cpu_b0 { // big CPU 核心簇 0 (Cortex-A76)
	cpu-supply = <&vdd_cpu_big0_s0>;     // 核心电压轨 (来自 I2C0 上的 RK8602)
	mem-supply = <&vdd_cpu_big0_mem_s0>; // 内存相关电压轨 (与核心电压相同)
};

&cpu_b2 { // big CPU 核心簇 1 (Cortex-A76)
	cpu-supply = <&vdd_cpu_big1_s0>;     // 核心电压轨 (来自 I2C0 上的 RK8603)
	mem-supply = <&vdd_cpu_big1_mem_s0>; // 内存相关电压轨 (与核心电压相同)
};

&gpu { // GPU 配置
	mali-supply = <&vdd_gpu_s0>;     // GPU 核心电压轨 (来自 PMIC DCDC_REG1)
	mem-supply = <&vdd_gpu_mem_s0>;  // GPU 内存相关电压轨 (与核心电压相同)
	upthreshold = <60>;              // GPU 负载上升阈值 (%)
	downdifferential = <30>;         // GPU 负载下降差值 (%)
	status = "okay";                 // 使能 GPU
};

&dfi { // DDR PHY 接口
	status = "okay"; // 使能
};

&dmc { // DDR 内存控制器
	status = "okay";               // 使能
	center-supply = <&vdd_ddr_s0>; // 中心电源 (来自 PMIC DCDC_REG5)
	mem-supply = <&vdd_log_s0>;    // 逻辑电源 (来自 PMIC DCDC_REG3)
};

// --- I2C 总线和设备配置 ---
&i2c4 { // I2C 总线 4
	status = "okay";             // 使能
	pinctrl-names = "default";
	pinctrl-0 = <&i2c4m3_xfer>;    // 配置使用的引脚 (I2C4_M3 SCL/SDA)
	// 此总线上没有挂载设备
};

&i2c3 { // I2C 总线 3
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c3m0_xfer>;    // 配置使用的引脚 (I2C3_M0 SCL/SDA)
	// 此总线上没有挂载设备
};

&rockchip_suspend { // Rockchip Suspend/Resume (PM) 配置
	status = "okay";
	rockchip,sleep-debug-en = <1>; // 使能睡眠调试信息输出
	rockchip,sleep-mode-config = < // 睡眠模式配置标志位
		(0
		| RKPM_SLP_ARMOFF_DDRPD // 允许 ARM 核关闭，DDR 进入 Power Down
		| RKPM_SLP_PMU_PMUALIVE_32K // PMU 保持活动，使用 32K 时钟
		| RKPM_SLP_PMU_DIS_OSC     // 允许 PMU 关闭高速振荡器
		| RKPM_SLP_32K_EXT         // 使用外部 32K 时钟源
		)
	>;
	rockchip,wakeup-config = < // 唤醒源配置标志位
		(0
		| RKPM_GPIO_WKUP_EN // 允许 GPIO 唤醒
		| RKPM_CPU0_WKUP_EN // 允许 CPU0 唤醒 (通常用于调试或特定中断)
		)
	>;
};

&i2c5 { // I2C 总线 5
	pinctrl-names = "default";
	pinctrl-0 = <&i2c5m2_xfer>;    // 配置使用的引脚 (I2C5_M2 SCL/SDA)
	status = "okay";

	gpio6: gpio-expander@21 { // PCA9535 GPIO 扩展器 1
		compatible = "nxp,pca9535"; // 兼容性字符串
		status = "okay";
		reg = <0x21>;               // I2C 设备地址
		gpio-controller;            // 声明为 GPIO 控制器
		#gpio-cells = <2>;          // 每个 GPIO 需要 2 个 cell (pin, flags)
		// pinctrl-names = "default"; // 中断引脚的 pinctrl (注释掉了)
		// pinctrl-0 = <&pinctrl_pca9535_1>;
		// interrupt-parent = <&gpio2>; // 中断控制器 (GPIO2)
		// interrupts = <RK_PC4 IRQ_TYPE_LEVEL_HIGH>; // 中断引脚 (GPIO2_C4) 和类型 (高电平触发)
		// interrupt-controller;       // 声明为中断控制器
		// #interrupt-cells = <2>;   // 每个中断需要 2 个 cell
	};
};

&i2c6 { // I2C 总线 6
	status = "okay";
	pinctrl-names = "default";
	pinctrl-0 = <&i2c6m0_xfer>;    // 配置使用的引脚 (I2C6_M0 SCL/SDA)

	gpio7: gpio-expander@21 { // PCA9535 GPIO 扩展器 2
		compatible = "nxp,pca9535";
		status = "okay";
		reg = <0x21>;               // I2C 设备地址 (注意: 与 i2c5 上的地址相同，需要确认硬件设计)
		gpio-controller;
		#gpio-cells = <2>;
		// pinctrl-names = "default";
		// pinctrl-0 = <&pinctrl_pca9535_2>;
		// interrupt-parent = <&gpio2>;
		// interrupts = <RK_PC5 IRQ_TYPE_LEVEL_HIGH>; // 中断引脚 (GPIO2_C5)
		// interrupt-controller;
		// #interrupt-cells = <2>;
	};
};

&i2c0 { // I2C 总线 0 (通常用于 PMIC 和 RTC)
	pinctrl-names = "default";
	pinctrl-0 = <&i2c0m2_xfer>;    // 配置使用的引脚 (I2C0_M2 SCL/SDA)
	status = "okay";

	hym8563: hym8563@51 { // HYM8563 RTC (实时时钟)
		compatible = "haoyu,hym8563"; // 兼容性字符串
		reg = <0x51>;                 // I2C 设备地址
		#clock-cells = <0>;           // 提供时钟，不需要 clock cell
		clock-frequency = <32768>;    // 时钟频率 (32.768 kHz)
		clock-output-names = "hym8563"; // 输出时钟名称
		pinctrl-names = "default";
		pinctrl-0 = <&hym8563_int>;   // 中断引脚 pinctrl 配置
		interrupt-parent = <&gpio0>;  // 中断控制器 (GPIO0)
		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>; // 中断引脚 (GPIO0_B0)，低电平触发
		wakeup-source;                // 可作为唤醒源
	};

	// --- 用于 CPU big Core 的 Buck 转换器 (在 I2C0 上) ---
	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 { // RK8602 Buck 转换器 (big core 0)
		compatible = "rockchip,rk8602"; // 兼容性字符串
		reg = <0x42>;                   // I2C 设备地址
		vin-supply = <&vcc5v0_sys>;     // 输入电源 (系统 5V)
		regulator-compatible = "rk860x-reg"; // 稳压器兼容性 (用于匹配内部稳压器驱动)
		regulator-name = "vdd_cpu_big0_s0"; // 稳压器名称
		regulator-min-microvolt = <550000>; // 最小电压 (0.55V)
		regulator-max-microvolt = <1050000>; // 最大电压 (1.05V)
		regulator-ramp-delay = <2300>;    // 电压爬升延迟 (单位不确定，可能是 us 或 ns)
		rockchip,suspend-voltage-selector = <1>; // 挂起时的电压选择器 (具体含义需查阅驱动)
		regulator-boot-on;                // 引导时开启
		regulator-always-on;              // 运行时常开
		regulator-state-mem {             // 内存相关状态
			regulator-off-in-suspend;     // 挂起时关闭
		};
	};

	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 { // RK8603 Buck 转换器 (big core 1)
		compatible = "rockchip,rk8603"; // 兼容性字符串
		reg = <0x43>;                   // I2C 设备地址
		vin-supply = <&vcc5v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_cpu_big1_s0";
		regulator-min-microvolt = <550000>; // 0.55V
		regulator-max-microvolt = <1050000>; // 1.05V
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};
};

&i2c1 { // I2C 总线 1
	pinctrl-names = "default";
	pinctrl-0 = <&i2c1m2_xfer>;    // 配置使用的引脚 (I2C1_M2 SCL/SDA)
	status = "okay";

	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 { // RK8602 Buck 转换器 (NPU)
		compatible = "rockchip,rk8602";
		reg = <0x42>;                   // I2C 地址 (注意: 与 i2c0 上的 RK8602 地址相同，需要确认硬件设计)
		vin-supply = <&vcc5v0_sys>;
		regulator-compatible = "rk860x-reg";
		regulator-name = "vdd_npu_s0";
		regulator-min-microvolt = <550000>; // 0.55V
		regulator-max-microvolt = <950000>;  // 0.95V
		regulator-ramp-delay = <2300>;
		rockchip,suspend-voltage-selector = <1>;
		regulator-boot-on;
		regulator-always-on;
		regulator-state-mem {
			regulator-off-in-suspend;
		};
	};

	/* Type-C 控制器 FUSB302 */
	usbc0: fusb302@22 {
		compatible = "fcs,fusb302";      // 兼容性字符串 (Fairchild Semiconductor FUSB302)
		reg = <0x22>;                    // I2C 设备地址
		interrupt-parent = <&gpio0>;     // 中断控制器 (GPIO0)
		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>; // 中断引脚 (GPIO0_C4)，低电平触发
		pinctrl-names = "default";
		pinctrl-0 = <&fusb302_int>;      // 中断引脚 pinctrl 配置
		vbus-supply = <&vbus_typec>;     // VBUS 电源控制节点
		status = "okay";

		ports { // 定义端口用于连接 USB 控制器和 PHY
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 { // 端口 0，用于 Role Switch
				reg = <0>;
				usbc0_role_sw: endpoint@0 { // 端点 0
					remote-endpoint = <&dwc3_0_role_switch>; // 连接到 USB DWC3 控制器 0 的角色切换端点
				};
			};
		};

		usb_con: connector { // USB Type-C 连接器属性
			compatible = "usb-c-connector"; // 兼容性字符串
			label = "USB-C";                 // 连接器标签
			data-role = "dual";              // 数据角色 (Host/Device)
			power-role = "dual";             // 电源角色 (Source/Sink)
			try-power-role = "sink";         // 优先尝试作为 Sink (受电端)
			op-sink-microwatt = <1000000>;   // 作为 Sink 时的操作功率 (1W)
			sink-pdos =                      // 作为 Sink 时支持的 PDO (Power Data Object)
				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>; // 支持 5V, 1A, 支持 USB 通信
			source-pdos =                    // 作为 Source 时提供的 PDO
				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>; // 提供 5V, 3A, 支持 USB 通信

			altmodes { // 支持的 Alternate Modes (如 DisplayPort)
				#address-cells = <1>;
				#size-cells = <0>;

				altmode@0 { // DP Alt Mode
					reg = <0>;
					svid = <0xff01>;    // Standard/Vendor ID (0xFF01 通常用于 DP)
					vdo = <0xffffffff>; // Vendor Defined Object (具体含义由 SVID 定义)
				};
			};

			ports { // 连接器端口，用于连接 PHY
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 { // 端口 0，用于 Orientation Switch
					reg = <0>;
					usbc0_orien_sw: endpoint { // 端点
						remote-endpoint = <&usbdp_phy0_orientation_switch>; // 连接到 USB/DP Combo PHY 0 的方向切换端点
					};
				};

				port@1 { // 端口 1，用于 DP Alt Mode Mux
					reg = <1>;
					dp_altmode_mux: endpoint { // 端点
						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>; // 连接到 USB/DP Combo PHY 0 的 DP Alt Mode Mux 端点
					};
				};
			};
		};
	};
};

&spi2 { // SPI 总线 2
	status = "okay";
	assigned-clocks = <&cru CLK_SPI2>; // 分配时钟
	assigned-clock-rates = <200000000>; // 时钟频率 (200 MHz) - 注意: PMIC 通信速率通常较低
	pinctrl-names = "default";
	pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>; // 配置使用的引脚 (SPI2_M2 CS0, CLK, TX, RX)
	num-cs = <1>;                      // 片选信号数量

	rk806single@0 { // RK806 PMIC (电源管理芯片)
		compatible = "rockchip,rk806";     // 兼容性字符串
		spi-max-frequency = <1000000>;     // SPI 最大通信频率 (1 MHz) - 这会覆盖上面的 200MHz
		reg = <0x0>;                       // SPI 片选索引 (CS0)

		interrupt-parent = <&gpio0>;       // 中断控制器 (GPIO0)
		interrupts = <RK_PA7 IRQ_TYPE_LEVEL_LOW>; // 中断引脚 (GPIO0_A7)，低电平触发

		pinctrl-names = "default", "pmic-power-off"; // pinctrl 状态名称
		pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>; // 默认状态引脚配置 (中断引脚 + DVS 引脚默认)
		pinctrl-1 = <&rk806_dvs1_pwrdn>; // PMIC 关机时的引脚配置 (DVS1 配置为 Power Down)

		/* 低电压阈值: 2800mv-3500mv */
		low_voltage_threshold = <3000>; // 低电压告警阈值 (3.0V)
		/* 关机电压阈值: 2700mv-3400mv */
		shutdown_voltage_threshold = <2700>; // 强制关机电压阈值 (2.7V)
		/* 关机温度阈值: 140°C 160°C */
		shutdown_temperture_threshold = <160>; // 过温关机阈值 (160°C)
		hotdie_temperture_threshold = <115>;   // 过热告警阈值 (115°C)

		/* PMIC 复位功能配置:
		 * 0: 重启 PMU;
		 * 1: 复位所有掉电复位寄存器, 强制状态切换到 ACTIVE 模式;
		 * 2: 复位所有掉电复位寄存器, 强制状态切换到 ACTIVE 模式, 同时拉低 RESETB 引脚 5ms 后释放
		 */
		pmic-reset-func = <1>; // 选择复位功能 1

		// --- PMIC 各路电源输入 ---
		vcc1-supply = <&vcc5v0_sys>; // DCDC_REG1/2/3/4 输入
		vcc2-supply = <&vcc5v0_sys>; // DCDC_REG5/9 输入
		vcc3-supply = <&vcc5v0_sys>; // DCDC_REG6 输入
		vcc4-supply = <&vcc5v0_sys>; // DCDC_REG7/8/10 输入
		vcc5-supply = <&vcc5v0_sys>; // PLDO_REG1/2 输入
		vcc6-supply = <&vcc5v0_sys>; // PLDO_REG3/4 输入
		vcc7-supply = <&vcc5v0_sys>; // PLDO_REG5 输入
		vcc8-supply = <&vcc5v0_sys>; // PLDO_REG6 输入
		vcc9-supply = <&vcc5v0_sys>; // NLDO_REG1/3 输入
		vcc10-supply = <&vcc5v0_sys>; // NLDO_REG2 输入
		vcc11-supply = <&vcc_2v0_pldo_s3>; // BOOST 输入? (来自 DCDC_REG7)
		vcc12-supply = <&vcc5v0_sys>; // VDD_RTC 输入
		vcc13-supply = <&vcc_1v1_nldo_s3>; // NLDO_REG4 输入 (来自外部 1.1V)
		vcc14-supply = <&vcc_1v1_nldo_s3>; // NLDO_REG5 输入 (来自外部 1.1V)
		vcca-supply = <&vcc5v0_sys>;  // VCCA 输入 (模拟电源)

		pwrkey { // PMIC 电源按键
			status = "okay"; // 使能 PMIC 内建的电源按键逻辑
		};

		pinctrl_rk806: pinctrl_rk806 { // RK806 PMIC GPIO/PwrCtrl 引脚功能定义
			gpio-controller;             // 声明为 GPIO 控制器 (用于 PwrCtrl 引脚)
			#gpio-cells = <2>;

			// 定义 PwrCtrl 引脚的不同功能 (用于 DVS - Dynamic Voltage Scaling)
			rk806_dvs1_null: rk806_dvs1_null { pins = "gpio_pwrctrl1"; function = "pin_fun0"; }; // 功能0: Null/高阻?
			rk806_dvs1_slp: rk806_dvs1_slp { pins = "gpio_pwrctrl1"; function = "pin_fun1"; };   // 功能1: Sleep
			rk806_dvs1_pwrdn: rk806_dvs1_pwrdn { pins = "gpio_pwrctrl1"; function = "pin_fun2"; }; // 功能2: Power Down
			rk806_dvs1_rst: rk806_dvs1_rst { pins = "gpio_pwrctrl1"; function = "pin_fun3"; };   // 功能3: Reset

			rk806_dvs2_null: rk806_dvs2_null { pins = "gpio_pwrctrl2"; function = "pin_fun0"; };
			rk806_dvs2_slp: rk806_dvs2_slp { pins = "gpio_pwrctrl2"; function = "pin_fun1"; };
			rk806_dvs2_pwrdn: rk806_dvs2_pwrdn { pins = "gpio_pwrctrl2"; function = "pin_fun2"; };
			rk806_dvs2_rst: rk806_dvs2_rst { pins = "gpio_pwrctrl2"; function = "pin_fun3"; };
			rk806_dvs2_dvs: rk806_dvs2_dvs { pins = "gpio_pwrctrl2"; function = "pin_fun4"; };   // 功能4: DVS
			rk806_dvs2_gpio: rk806_dvs2_gpio { pins = "gpio_pwrctrl2"; function = "pin_fun5"; }; // 功能5: GPIO

			rk806_dvs3_null: rk806_dvs3_null { pins = "gpio_pwrctrl3"; function = "pin_fun0"; };
			rk806_dvs3_slp: rk806_dvs3_slp { pins = "gpio_pwrctrl3"; function = "pin_fun1"; };
			rk806_dvs3_pwrdn: rk806_dvs3_pwrdn { pins = "gpio_pwrctrl3"; function = "pin_fun2"; };
			rk806_dvs3_rst: rk806_dvs3_rst { pins = "gpio_pwrctrl3"; function = "pin_fun3"; };
			rk806_dvs3_dvs: rk806_dvs3_dvs { pins = "gpio_pwrctrl3"; function = "pin_fun4"; };
			rk806_dvs3_gpio: rk806_dvs3_gpio { pins = "gpio_pwrctrl3"; function = "pin_fun5"; };
		};

		regulators { // PMIC 内部稳压器定义
			// DCDC Buck 转换器
			vdd_gpu_s0: vdd_gpu_mem_s0: DCDC_REG1 { // GPU 电源
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <550000>; // 0.55V
				regulator-max-microvolt = <950000>;  // 0.95V
				regulator-ramp-delay = <12500>;      // 电压爬升速率 (12.5mV/us?)
				regulator-name = "vdd_gpu_s0";
				regulator-state-mem {
					regulator-off-in-suspend;      // 挂起时关闭
				};
			};

			vdd_cpu_lit_s0: vdd_cpu_lit_mem_s0: DCDC_REG2 { // CPU LITTLE Core 电源
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <550000>; // 0.55V
				regulator-max-microvolt = <950000>;  // 0.95V
				regulator-ramp-delay = <12500>;
				regulator-name = "vdd_cpu_lit_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};

			vdd_log_s0: DCDC_REG3 { // SoC 逻辑电压
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <750000>; // 0.75V
				regulator-max-microvolt = <750000>; // 0.75V
				regulator-ramp-delay = <12500>;
				regulator-name = "vdd_log_s0";
				regulator-state-mem {
					regulator-on-in-suspend;       // 挂起时保持开启
				};
			};

			vdd_vdenc_s0: vdd_vdenc_mem_s0: DCDC_REG4 { // 视频编码器电源
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <550000>; // 0.55V
				regulator-max-microvolt = <950000>;  // 0.95V
				regulator-init-microvolt = <750000>; // 初始电压 0.75V
				regulator-ramp-delay = <12500>;
				regulator-name = "vdd_vdenc_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};

			vdd_ddr_s0: DCDC_REG5 { // DDR 控制器中心电源
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <850000>; // 0.85V
				regulator-max-microvolt = <850000>; // 0.85V
				regulator-ramp-delay = <12500>;
				regulator-name = "vdd_ddr_s0";
				regulator-state-mem {
					regulator-off-in-suspend;      // 挂起时关闭 (DDR 进入自刷新)
					regulator-suspend-microvolt = <850000>; // 挂起电压 (虽然关闭，但可能驱动需要知道)
				};
			};

			vdd2_ddr_s3: DCDC_REG6 { // DDR VDD2 (待机电源?)
				regulator-always-on;
				regulator-boot-on;
				regulator-name = "vdd2_ddr_s3";
				regulator-state-mem {
					regulator-on-in-suspend;       // 挂起时保持开启
				};
			};

			vcc_2v0_pldo_s3: DCDC_REG7 { // 2.0V (PLDO 输入源? S3 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <2000000>; // 2.0V
				regulator-max-microvolt = <2000000>; // 2.0V
				regulator-name = "vdd_2v0_pldo_s3"; // 名称似乎应为 vcc_2v0_pldo_s3
				regulator-state-mem {
					regulator-on-in-suspend;
					regulator-suspend-microvolt = <2000000>;
				};
			};

			vcc_3v3_s3: DCDC_REG8 { // 系统 3.3V (待机 S3 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <3300000>; // 3.3V
				regulator-max-microvolt = <3300000>; // 3.3V
				regulator-name = "vcc_3v3_s3";
				regulator-state-mem {
					regulator-on-in-suspend;
				};
			};

			vddq_ddr_s0: DCDC_REG9 { // DDR VDDQ (IO 电压)
				regulator-always-on;
				regulator-boot-on;
				regulator-name = "vddq_ddr_s0";
				regulator-state-mem {
					regulator-off-in-suspend;      // 挂起时关闭
				};
			};

			vcc_1v8_s3: DCDC_REG10 { // 系统 1.8V (待机 S3 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1800000>; // 1.8V
				regulator-max-microvolt = <1800000>; // 1.8V
				regulator-name = "vcc_1v8_s3";
				regulator-state-mem {
					regulator-on-in-suspend;
					regulator-suspend-microvolt = <1800000>;
				};
			};

			// PLDO (Programmable Low Dropout Regulator)
			vcc_1v8_s0: PLDO_REG1 { // 系统 1.8V (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1800000>; // 1.8V
				regulator-max-microvolt = <1800000>; // 1.8V
				regulator-name = "vcc_1v8_s0";
				regulator-state-mem {
					regulator-on-in-suspend;       // 挂起时保持开启 (可能用于唤醒逻辑)
				};
			};

			avcc_1v8_s0: PLDO_REG2 { // 模拟 1.8V (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1800000>; // 1.8V
				regulator-max-microvolt = <1800000>; // 1.8V
				regulator-name = "avcc_1v8_s0";
				regulator-state-mem {
					regulator-off-in-suspend;      // 挂起时关闭
					regulator-suspend-microvolt = <1800000>;
				};
			};

			avdd_1v2_s0: PLDO_REG3 { // 模拟 1.2V (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1200000>; // 1.2V
				regulator-max-microvolt = <1200000>; // 1.2V
				regulator-name = "avdd_1v2_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};

			avcc_3v3_s0: PLDO_REG4 { // 模拟 3.3V (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <3300000>; // 3.3V
				regulator-max-microvolt = <3300000>; // 3.3V
				regulator-name = "avcc_3v3_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};

			vccio_sd_s0: PLDO_REG5 { // SD 卡 IO 电压 (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1800000>; // 最小 1.8V
				regulator-max-microvolt = <3300000>; // 最大 3.3V (可调)
				regulator-name = "vccio_sd_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};

			pldo6_s3: PLDO_REG6 { // 另一个 PLDO (待机 S3 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <1800000>; // 1.8V
				regulator-max-microvolt = <1800000>; // 1.8V
				regulator-name = "pldo6_s3";
				regulator-state-mem {
					regulator-on-in-suspend;
					regulator-suspend-microvolt = <1800000>;
				};
			};

			// NLDO (Nano Low Dropout Regulator)
			vdd_0v75_s3: NLDO_REG1 { // 0.75V (待机 S3 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <750000>; // 0.75V
				regulator-max-microvolt = <750000>; // 0.75V
				regulator-name = "vdd_0v75_s3";
				regulator-state-mem {
					regulator-on-in-suspend;
					regulator-suspend-microvolt = <750000>;
				};
			};

			avdd_ddr_pll_s0: NLDO_REG2 { // DDR PLL 模拟电源 (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <850000>; // 0.85V
				regulator-max-microvolt = <850000>; // 0.85V
				regulator-name = "avdd_ddr_pll_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
					regulator-suspend-microvolt = <850000>;
				};
			};

			avdd_0v75_s0: NLDO_REG3 { // 模拟 0.75V (工作 S0 状态)
				regulator-always-on;
				regulator-boot-on;
				regulator-min-microvolt = <750000>; // 0.75V
				regulator-max-microvolt = <750000>; // 0.75V
				regulator-name = "avdd_0v75_s0";
				regulator-state-mem {
					regulator-off-in-suspend;
				};
			};
		}; // regulators 结束
	}; // rk806single@0 结束
}; // spi2 结束

&i2c7 { // I2C 总线 7
	pinctrl-names = "default";
	pinctrl-0 = <&i2c7m0_xfer>;    // 配置使用的引脚 (I2C7_M0 SCL/SDA)
	status = "okay";

	es8388: es8388@11 { // ES8388 音频 Codec
		status = "okay";
		#sound-dai-cells = <0>;     // DAI (Digital Audio Interface) cell 数量
		compatible = "everest,es8388", "everest,es8323"; // 兼容性列表 (ES8388, ES8323)
		reg = <0x11>;               // I2C 设备地址
		clocks = <&mclkout_i2s0>;   // 输入时钟源 (来自 I2S0 MCLK 输出)
		clock-names = "mclk";       // 时钟名称
		assigned-clocks = <&mclkout_i2s0>; // 分配的时钟
		assigned-clock-rates = <12288000>; // 分配的时钟频率 (12.288 MHz = 256 * 48kHz)
		pinctrl-names = "default";
		pinctrl-0 = <&i2s0_mclk>;     // MCLK 引脚的 pinctrl 配置
	};
};

&i2s0_8ch { // I2S0 (8通道)
	status = "okay";
	rockchip,clk-trcm = <1>; // 时钟同步模式 (Transmit/Receive Clock Mode)
	pinctrl-0 = <&i2s0_lrck   // 配置使用的引脚
			 &i2s0_sclk
			 &i2s0_sdi0 // Data In 0
			 &i2s0_sdo0>; // Data Out 0
};

&saradc { // SAR ADC (逐次逼近型模拟数字转换器)
	status = "okay";
	vref-supply = <&avcc_1v8_s0>; // 参考电压源 (模拟 1.8V)
};

&tsadc { // TS ADC (温度传感器 ADC)
	status = "okay"; // 使能温度传感器
};

// --- 存储接口 ---
&sdhci { // SDHCI 控制器 (用于 eMMC)
	bus-width = <8>;                 // 总线宽度 (8位)
	no-sdio;                         // 不支持 SDIO 卡
	no-sd;                           // 不支持 SD 卡 (这个接口专用给 eMMC)
	non-removable;                   // 不可移除设备 (eMMC)
	max-frequency = <200000000>;     // 最大频率 (200 MHz)
	mmc-hs400-1_8v;                  // 支持 HS400 模式 (1.8V IO)
	mmc-hs400-enhanced-strobe;       // 支持 HS400 增强型选通信号
	// keep-power-in-suspend;         // 挂起时保持供电 (注释掉了)
	// mmc-hs200-1_8v;                // 支持 HS200 模式 (1.8V IO) (注释掉了, HS400 优先)
	full-pwr-cycle-in-suspend;       // 挂起/恢复时执行完整的电源周期 (可能为了稳定性)
	status = "okay";
};

&sdmmc { // SDMMC 控制器 (用于 TF 卡槽)
	max-frequency = <200000000>;     // 最大频率 (200 MHz)
	no-sdio;                         // 不支持 SDIO 卡
	no-mmc;                          // 不支持 MMC 卡 (这个接口专用给 SD 卡)
	bus-width = <4>;                 // 总线宽度 (4位)
	cap-mmc-highspeed;               // 支持 MMC HighSpeed 模式 (虽然 no-mmc, 但能力声明可能保留)
	cap-sd-highspeed;                // 支持 SD HighSpeed 模式
	disable-wp;                      // 禁用写保护检测引脚
	sd-uhs-sdr104;                   // 支持 SD UHS SDR104 模式
	vmmc-supply = <&vcc_3v3_sd_s3>;  // 卡电源 (3.3V)
	vqmmc-supply = <&vccio_sd_s0>;   // IO 电源 (由 PMIC PLDO_REG5 提供，可调 1.8V/3.3V)
	pinctrl-names = "default";
	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>; // 配置使用的引脚 (4位数据, CLK, CMD, 卡检测)
	status = "okay";
};

// --- 多媒体处理单元 ---
&iep { // IEP (图像增强处理器)
	status = "okay";
};

&iep_mmu { // IEP MMU
	status = "okay";
};

&jpegd { // JPEG 解码器
	status = "okay";
};

&jpegd_mmu { // JPEG 解码器 MMU
	status = "okay";
};

&jpege_ccu { // JPEG 编码器 CCU (Camera Control Unit?)
	status = "okay";
};

&jpege0 { // JPEG 编码器 0
	status = "okay";
};

&jpege0_mmu { // JPEG 编码器 0 MMU
	status = "okay";
};

&jpege1 { // JPEG 编码器 1
	status = "okay";
};

&jpege1_mmu { // JPEG 编码器 1 MMU
	status = "okay";
};

&jpege2 { // JPEG 编码器 2
	status = "okay";
};

&jpege2_mmu { // JPEG 编码器 2 MMU
	status = "okay";
};

&jpege3 { // JPEG 编码器 3
	status = "okay";
};

&jpege3_mmu { // JPEG 编码器 3 MMU
	status = "okay";
};

&mpp_srv { // MPP (Media Process Platform) 服务?
	status = "okay";
};

// --- PWM 控制器 ---
&pwm4 { // PWM 控制器 4 (用于风扇)
	pinctrl-0 = <&pwm4m0_pins>; // 配置引脚 (PWM4_M0)
	status = "okay";
};

&pwm2 { // PWM 控制器 2
	pinctrl-0 = <&pwm2m0_pins>; // 配置引脚 (PWM2_M0)
	status = "okay";
};

&pwm6 { // PWM 控制器 6
	pinctrl-0 = <&pwm6m0_pins>; // 配置引脚 (PWM6_M0)
	status = "okay";
};

&pwm3 { // PWM 控制器 3 (用于红外接收)
	compatible = "rockchip,remotectl-pwm"; // 使用 Rockchip 红外遥控 PWM 驱动
	pinctrl-names = "default";
	pinctrl-0 = <&pwm3m1_pins>; // 配置引脚 (PWM3_M1_IR)
	remote_pwm_id = <3>;       // PWM ID
	handle_cpu_id = <1>;       // 处理中断的 CPU ID
	remote_support_psci = <0>; // 是否支持 PSCI (Power State Coordination Interface)
	status = "okay";

	ir_key_lemonpi { // 红外按键码表 (柠檬派)
		rockchip,usercode = <0xff00>; // 用户码/设备码
		rockchip,key_table =         // 按键码和 Linux 输入事件码映射
			<0xba   KEY_POWER>,      // 电源
			<0xb8   KEY_MENU>,       // 菜单
			<0xbc   KEY_BACK>,       // 返回
			<0xbb   KEY_HOME>,       // Home
			<0xea   KEY_PLAY>,       // 播放
			<0xbf   KEY_VOLUMEUP>,   // 音量加
			<0xe6   KEY_VOLUMEDOWN>, // 音量减
			<0xf6   KEY_FASTFORWARD>,// 快进
			<0xf8   KEY_FASTREVERSE>,// 快退
			<0xf2   KEY_BACKSPACE>,  // 退格
			<0xf3   KEY_1>,          // 数字 1
			<0xe7   KEY_2>,          // 数字 2
			<0xa1   KEY_3>,          // 数字 3
			<0xf7   KEY_4>,          // 数字 4
			<0xe3   KEY_5>,          // 数字 5
			<0xa5   KEY_6>,          // 数字 6
			<0xbd   KEY_7>,          // 数字 7
			<0xad   KEY_8>,          // 数字 8
			<0xb5   KEY_9>,          // 数字 9
			<0xe9   KEY_0>;          // 数字 0
	};
};

// --- RGA (2D 图形加速单元) ---
&rga3_core0 { // RGA3 核心 0
	status = "okay";
};

&rga3_0_mmu { // RGA3 核心 0 MMU
	status = "okay";
};

&rga3_core1 { // RGA3 核心 1
	status = "okay";
};

&rga3_1_mmu { // RGA3 核心 1 MMU
	status = "okay";
};

&rga2 { // RGA2 (向下兼容?)
	status = "okay";
};

// --- NPU (神经网络处理单元) ---
&rknpu {
	rknpu-supply = <&vdd_npu_s0>; // NPU 电源 (来自 I2C1 上的 RK8602)
	mem-supply = <&vdd_npu_mem_s0>; // NPU 内存相关电源 (与核心相同)
	status = "okay";
};

&rknpu_mmu { // NPU MMU
	status = "okay";
};

// --- 视频解码器 ---
&rkvdec_ccu { // VDEC CCU
	status = "okay";
};

&rkvdec0 { // VDEC 0
	status = "okay";
};

&rkvdec0_mmu { // VDEC 0 MMU
	status = "okay";
};

&rkvdec1 { // VDEC 1
	status = "okay";
};

&rkvdec1_mmu { // VDEC 1 MMU
	status = "okay";
};

// --- 视频编码器 ---
&rkvenc_ccu { // VENC CCU
	status = "okay";
};

&rkvenc0 { // VENC 0
	status = "okay";
};

&rkvenc0_mmu { // VENC 0 MMU
	status = "okay";
};

&rkvenc1 { // VENC 1
	status = "okay";
};

&rkvenc1_mmu { // VENC 1 MMU
	status = "okay";
};

&rkvtunnel { // RKV Tunnel (用于视频数据通路?)
	status = "okay";
};

/* 这是看门狗 */
&wdt { // Watchdog Timer
	status = "okay"; // 使能看门狗
};

// --- 以太网 MAC 控制器 (GMAC) ---
&gmac0 { // GMAC 0
	/* 使用 rgmii-rxid 模式禁用 SoC 内部的 RX 延迟 */
	phy-mode = "rgmii-rxid"; // PHY 接口模式 (RGMII，带内部 RX 延迟)
	clock_in_out = "output"; // 时钟方向 (SoC 输出 RGMII TX 时钟)

	snps,reset-gpio = <&gpio4 RK_PC6 GPIO_ACTIVE_LOW>; // PHY 复位 GPIO (GPIO4_C6)，低电平有效
	snps,reset-active-low;          // 声明复位信号是低电平有效
	/* 复位时间 20ms, RTL8211F 需要 100ms */
	snps,reset-delays-us = <0 20000 100000>; // 复位时序 (before: 0us, assert: 20ms, after: 100ms)

	pinctrl-names = "default";
	pinctrl-0 = <&gmac0_miim       // 配置 MIIM (MDIO) 接口引脚
			 &gmac0_tx_bus2   // 配置 RGMII TX 总线引脚 (模式2)
			 &gmac0_rx_bus2   // 配置 RGMII RX 总线引脚 (模式2)
			 &gmac0_rgmii_clk // 配置 RGMII 时钟引脚
			 &gmac0_rgmii_bus>; // 配置 RGMII 控制信号引脚

	tx_delay = <0x20>;            // RGMII TX 延迟配置 (32 * 0.1ns = 3.2ns? 具体单位需查阅文档)
	/* rx_delay = <0x4f>; */      // RGMII RX 延迟配置 (注释掉了，因为使用了 rgmii-rxid)

	phy-handle = <&rgmii_phy0>;   // 指向对应的 PHY 设备节点
	status = "okay";
};

&gmac1 { // GMAC 1
	/* 使用 rgmii-rxid 模式禁用 SoC 内部的 RX 延迟 */
	phy-mode = "rgmii-rxid";
	clock_in_out = "output";

	snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>; // PHY 复位 GPIO (GPIO3_B7)
	snps,reset-active-low;
	/* 复位时间 20ms, RTL8211F 需要 100ms */
	snps,reset-delays-us = <0 20000 100000>;

	pinctrl-names = "default";
	pinctrl-0 = <&gmac1_miim       // 配置 MIIM (MDIO) 接口引脚
			 &gmac1_tx_bus2   // 配置 RGMII TX 总线引脚 (模式2)
			 &gmac1_rx_bus2   // 配置 RGMII RX 总线引脚 (模式2)
			 &gmac1_rgmii_clk // 配置 RGMII 时钟引脚
			 &gmac1_rgmii_bus>; // 配置 RGMII 控制信号引脚

	tx_delay = <0x20>;
	/* rx_delay = <0x4f>; */

	phy-handle = <&rgmii_phy1>;   // 指向对应的 PHY 设备节点
	status = "okay";
};

// --- MDIO 总线 (用于管理 PHY) ---
&mdio0 { // MDIO 总线 0 (连接到 GMAC0)
	rgmii_phy0: phy@0 { // RGMII PHY 设备 0
		compatible = "ethernet-phy-ieee802.3-c22"; // 兼容标准的 C22 PHY
		reg = <0x00>;                         // PHY 地址
		// 以下为 JLsemi (劲龙微电子) PHY 的特定配置
		jl2xxx,led-enable = <(JL2XXX_LED_STATIC_OP_EN | JL1XXX_LED_MODE_EN)>; // 使能 LED 静态操作和模式配置
		jl2xxx,led-mode = <(JL2XXX_LED1_LINK10  | \ // LED1: 10M/100M/1000M Link 状态常亮
				 JL2XXX_LED1_LINK100  | \
				 JL2XXX_LED1_LINK1000 | \
				 JL2XXX_LED2_LINK10   | \ // LED2: 10M/100M/1000M Link 状态常亮 + Activity 闪烁
				 JL2XXX_LED2_LINK100  | \
				 JL2XXX_LED2_LINK1000 | \
				 JL2XXX_LED2_ACTIVITY )>; //JL PHY
	};
};

&mdio1 { // MDIO 总线 1 (连接到 GMAC1)
	rgmii_phy1: phy@0 { // RGMII PHY 设备 1
		compatible = "ethernet-phy-ieee802.3-c22";
		reg = <0x00>;                         // PHY 地址
		// JLsemi PHY 特定配置
		jl2xxx,led-enable = <(JL2XXX_LED_STATIC_OP_EN | JL1XXX_LED_MODE_EN)>;
		jl2xxx,led-mode = <(JL2XXX_LED1_LINK10  | \
				 JL2XXX_LED1_LINK100  | \
				 JL2XXX_LED1_LINK1000 | \
				 JL2XXX_LED2_LINK10   | \
				 JL2XXX_LED2_LINK100  | \
				 JL2XXX_LED2_LINK1000 | \
				 JL2XXX_LED2_ACTIVITY )>; //JL PHY
	};
};

// --- PCIe (PCI Express) ---
/* PCIe30 PHY Port0 & Port1 */
&pcie30phy { // PCIe 3.0 Combo PHY (支持 Port0 x4 或 Port0 x2 + Port1 x2)
	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>; // 配置为聚合模式 (PCIe x4 for Port0)
	status = "okay";
};

// PCIe30 Port0 & Port1: M.2 M-Key 插槽 (通常用于 NVMe SSD)
&pcie3x4 { // PCIe 3.0 x4 控制器 (对应 PHY Port0)
	reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>; // M.2 插槽复位 GPIO (GPIO1_B2)，高电平有效
	vpcie3v3-supply = <&vcc3v3_sys>;              // PCIe 3.3V 电源轨
	status = "okay";
};

/* SATA30_HOST1/PCIe20x1_0 Combo PHY */
&combphy1_ps { // Combo PHY 1 (PCIe/SATA)
	status = "okay"; // 使能该 PHY，具体模式由控制器决定
};

// M.2 E-Key 插槽 (通常用于 WiFi/BT 模块)
&pcie2x1l0 { // PCIe 2.0 x1 控制器 (Lane 0, 对应 Combo PHY 1)
	reset-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>; // M.2 E-Key 复位 GPIO (GPIO4_A5)，高电平有效
	// disable-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>; // 禁用 GPIO (WiFi_DIS/BT_DIS?)，高电平禁用 (注释掉了，但可能需要根据模块启用)
	status = "okay";
};

/* SATA30/PCIe20x1_2 Combo PHY */
&combphy0_ps { // Combo PHY 0 (PCIe/SATA)
	status = "okay"; // 使能该 PHY
};

// Mini-PCIe 插槽 (可能与 SATA 或 PCIe 复用)
&sata0 { // SATA 0 控制器 (对应 Combo PHY 0)
	status = "okay"; // 使能 SATA 功能
};

&pcie2x1l2 { // PCIe 2.0 x1 控制器 (Lane 2, 对应 Combo PHY 0)
	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;   // Mini-PCIe 复位 GPIO (GPIO3_D1)，高电平有效
	// disable-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>; // 禁用 GPIO (注释掉了)
	status = "disabled"; // 默认禁用 PCIe，优先使用 SATA0 (根据板卡设计二选一)
};

// --- USB 和 DP (DisplayPort) ---
/* USB3.1/DP Combo PHY1 */
&usbdp_phy1 { // USB/DP Combo PHY 1 (连接到 USB Host / DP TX1)
	status = "okay";
};

&usbdp_phy1_u3 { // Combo PHY 1 的 USB3 部分
	status = "okay";
};

&usbdrd3_1 { // USB DRD (Dual Role Device) 控制器 1 (连接到 Combo PHY 1)
	status = "okay";
};

&usbdrd_dwc3_1 { // Synopsys DWC3 USB 控制器实例 1
	status = "okay";
	dr_mode = "host"; // 配置为 Host 模式 (连接到 Type-A 或类似 Host 接口)
};

/* USB3.1/DP Combo PHY0 */
&usbdp_phy0 { // USB/DP Combo PHY 0 (连接到 Type-C)
	orientation-switch; // 支持 Type-C 正反插切换
	svid = <0xff01>;    // Standard/Vendor ID for DP Alt Mode
	sbu1-dc-gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>; // SBU1 用于 DP Alt Mode 的 GPIO 控制 (高电平使能?)
	sbu2-dc-gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>; // SBU2 用于 DP Alt Mode 的 GPIO 控制 (高电平使能?)
	status = "okay";

	port { // 定义端口用于连接 Type-C 控制器和 DP/USB 控制器
		#address-cells = <1>;
		#size-cells = <0>;
		usbdp_phy0_orientation_switch: endpoint@0 { // 端点 0: 方向切换
			reg = <0>;
			remote-endpoint = <&usbc0_orien_sw>; // 连接到 FUSB302 的方向切换端点
		};

		usbdp_phy0_dp_altmode_mux: endpoint@1 { // 端点 1: DP Alt Mode Mux
			reg = <1>;
			remote-endpoint = <&dp_altmode_mux>; // 连接到 FUSB302 的 DP Alt Mode Mux 端点
		};
	};
};

&usbdp_phy0_u3 { // Combo PHY 0 的 USB3 部分
	status = "okay";
};

&usbdp_phy0_dp { // Combo PHY 0 的 DP 部分
	status = "okay";
};

/* USB3.1 OTG0 Controller */
&usbdrd3_0 { // USB DRD 控制器 0 (连接到 Combo PHY 0)
	status = "okay";
};

&usbdrd_dwc3_0 { // Synopsys DWC3 USB 控制器实例 0 (Type-C 接口)
	dr_mode = "otg";      // 配置为 OTG (On-The-Go) 模式
	usb-role-switch;      // 支持 USB 角色切换 (通过 FUSB302)
	status = "okay";

	port { // 定义端口用于连接 Type-C 控制器
		#address-cells = <1>;
		#size-cells = <0>;
		dwc3_0_role_switch: endpoint@0 { // 端点 0: 角色切换
			reg = <0>;
			remote-endpoint = <&usbc0_role_sw>; // 连接到 FUSB302 的角色切换端点
		};
	};
};

/* USB2.0 PHY0 */
&u2phy0 { // USB 2.0 PHY 0 (与 Type-C 接口的 USB 2.0 复用)
	status = "okay";
};

&u2phy0_otg { // USB 2.0 PHY 0 的 OTG 部分
	rockchip,typec-vbus-det; // 使用 Type-C VBUS 检测来判断模式 (Host/Device)
	status = "okay";
};

/* USB2.0 PHY1 */
&u2phy1 { // USB 2.0 PHY 1 (与 Combo PHY 1 的 USB 2.0 复用)
	status = "okay";
};

&u2phy1_otg { // USB 2.0 PHY 1 的 OTG 部分 (虽然上层配置为 Host，但 PHY 驱动节点可能保留 OTG)
	status = "okay";
};

/* USB3.1/SATA/PCIe20x1_1 Combo PHY */
&combphy2_psu { // Combo PHY 2 (PCIe/SATA/USB3)
	status = "okay"; // 使能该 PHY
};

/* USB3.1 HOST2 Controller */
&usbhost3_0 { // USB 3.1 Host 控制器 (连接到 Combo PHY 2)
	status = "okay";
};

&usbhost_dwc3_0 { // Synopsys DWC3 USB 控制器实例 (作为 Host)
	dr_mode = "host"; // 配置为 Host 模式
	status = "okay";
};

/* USB2.0 HOST0 PHY2 */
&u2phy2 { // USB 2.0 PHY 2 (独立 Host 接口)
	status = "okay";
};

&u2phy2_host { // USB 2.0 PHY 2 的 Host 部分
	phy-supply = <&vcc5v0_usb>; // PHY 电源 (USB 5V)
	status = "okay";
};

/* USB2.0 HOST0 Controller */
&usb_host0_ehci { // EHCI 控制器 (USB 2.0 Host)
	status = "okay";
};

&usb_host0_ohci { // OHCI 控制器 (USB 1.1 Host, 兼容)
	status = "okay";
};

/* USB2.0 HOST1 PHY3 */
&u2phy3 { // USB 2.0 PHY 3 (独立 Host 接口)
	status = "okay";
};

&u2phy3_host { // USB 2.0 PHY 3 的 Host 部分
	phy-supply = <&vcc5v0_usb>; // PHY 电源 (USB 5V)
	status = "okay";
};

/* USB2.0 HOST1 Controller */
&usb_host1_ehci { // EHCI 控制器 (USB 2.0 Host)
	status = "okay";
};

&usb_host1_ohci { // OHCI 控制器 (USB 1.1 Host, 兼容)
	status = "okay";
};

// --- VPU (Video Processing Unit) ---
&vdpu { // VDPU (Video Decode Process Unit?)
	status = "okay";
};

&vdpu_mmu { // VDPU MMU
	status = "okay";
};

&vepu { // VEPU (Video Encode Process Unit?)
	status = "okay";
};

// --- 显示输出配置 (VOP - Video Output Processor) ---
/* dp0 display */
&dp0 { // DisplayPort 0 控制器
	status = "okay";
};

&route_dp0 { // DP0 的视频数据路由
	status = "okay";
	connect = <&vp1_out_dp0>; // 将 VOP VP1 的输出连接到 DP0
};

// 定义 DP0 可以接收哪个 VOP VP (Video Port) 的数据
&dp0_in_vp0 { status = "disabled"; }; // 禁止 VP0 -> DP0
&dp0_in_vp1 { status = "okay"; };     // 允许 VP1 -> DP0
&dp0_in_vp2 { status = "disabled"; }; // 禁止 VP2 -> DP0

&route_hdmi1 { // HDMI1 的视频数据路由
	status = "okay";
	connect = <&vp0_out_hdmi1>; // 将 VOP VP0 的输出连接到 HDMI1
};

// 定义 HDMI1 可以接收哪个 VOP VP 的数据
&hdmi1_in_vp0 { status = "okay"; };     // 允许 VP0 -> HDMI1
&hdmi1_in_vp1 { status = "disabled"; }; // 禁止 VP1 -> HDMI1
&hdmi1_in_vp2 { status = "disabled"; }; // 禁止 VP2 -> HDMI1

&hdmi1 { // HDMI 1 控制器
	enable-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>; // HDMI 使能 GPIO (GPIO1_C6)，高电平有效
	status = "okay";
};

&vop { // VOP (Video Output Processor)
	status = "okay";
	// disable-win-move; // 禁用窗口移动优化 (注释掉了)
};

&vop_mmu { // VOP MMU
	status = "okay";
};

&hdmirx_ctrler { // HDMI RX (输入) 控制器
	status = "okay";
	#sound-dai-cells = <1>; // 提供音频 DAI，需要 1 个 cell (索引)
	/* 用于触发 HPD 的有效电平: 0-低, 1-高 */
	hpd-trigger-level = <1>; // HPD (Hot Plug Detect) 触发电平 (高电平表示连接)
	hdmirx-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_LOW>; // HDMI 输入检测 GPIO (GPIO1_D5)，低电平有效 (表示有输入?)
	pinctrl-0 = <&hdmim1_rx_cec &hdmim1_rx_hpdin &hdmim1_rx_scl &hdmim1_rx_sda &hdmirx_det>; // 配置 CEC, HPD_IN, I2C(SCL/SDA), 检测引脚
	pinctrl-names = "default";
};

/* HDMI IN Audio */
&hdmiin_sound { // HDMI 输入音频节点 (前面已定义，此处确保状态)
	status = "okay"; // 在 hdmirx_ctrler 使能时，这个也使能
};

&i2s7_8ch { // I2S7 (8通道，用于 HDMI 输入音频)
	status = "okay";
};

/* vp0 & vp1 拼接用于 8K 输出 (或者双 4K 输出) */
&vp0 { // VOP Video Port 0
	// 定义 VP0 控制的图层/窗口资源
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>; // 控制 Cluster 0 和 Esmart 0
	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>; // 主图层使用 Esmart 0
	// cursor-win-id = <ROCKCHIP_VOP2_CLUSTER0>; // 光标层使用 Cluster 0 (注释掉了)
};

&vp1 { // VOP Video Port 1
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>; // 控制 Cluster 1 和 Esmart 1
	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>; // 主图层使用 Esmart 1
	cursor-win-id = <ROCKCHIP_VOP2_CLUSTER1>;       // 光标层使用 Cluster 1
};

&vp2 { // VOP Video Port 2
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>; // 控制 Cluster 2 和 Esmart 2
	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>; // 主图层使用 Esmart 2
	cursor-win-id = <ROCKCHIP_VOP2_CLUSTER2>;       // 光标层使用 Cluster 2
};

&vp3 { // VOP Video Port 3
	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>; // 控制 Cluster 3 和 Esmart 3
	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>; // 主图层使用 Esmart 3
	cursor-win-id = <ROCKCHIP_VOP2_CLUSTER3>;       // 光标层使用 Cluster 3
};

&display_subsystem { // 显示子系统
	// 为显示子系统提供时钟 (用于 HDMI PHY)
	clocks = <&hdptxphy_hdmi0>, <&hdptxphy_hdmi1>;
	clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
	status = "okay"; // 使能
};

&hdptxphy_hdmi0 { // HDMI TX PHY 0
	status = "okay";
};

&hdptxphy_hdmi1 { // HDMI TX PHY 1
	status = "okay";
};

// --- 引脚控制 (Pinctrl) 配置 ---
&pinctrl {
	// RTC 中断引脚
	hym8563 {
		hym8563_int: hym8563-int {
			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>; // GPIO0_B0, GPIO 功能, 上拉
		};
	};

	// 耳机相关引脚
	headphone {
		hp_det: hp-det {
			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>; // GPIO1_D3, GPIO 功能, 无上下拉
		};
	};

	// Type-C 相关引脚
	usb-typec {
		fusb302_int: fusb302-int {
			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>; // GPIO0_C4, GPIO 功能, 上拉
		};

		typec_vbus_en: typec-vbus-en {
			rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>; // GPIO2_B5, GPIO 功能, 无上下拉
		};
	};

	// LED 引脚
	leds {
		sys_led_pin: sys-led-pin {
			rockchip,pins = <0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>; // GPIO0_D3, GPIO 功能, 无上下拉
		};
	};

	// HDMI RX 相关引脚
	hdmirx {
		hdmirx_det: hdmirx-det {
			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>; // GPIO1_D5, GPIO 功能, 上拉
		};
	};

	// IO 扩展器中断引脚 (在 i2c5/i2c6 节点中被注释掉了)
	io {
		pinctrl_pca9535_1: pinctrl-pca9535-1 {
			rockchip,pins = <2 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>; // GPIO2_C4, GPIO 功能, 无上下拉
		};
		pinctrl_pca9535_2: pinctrl-pca9535-2 {
			rockchip,pins = <2 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>; // GPIO2_C5, GPIO 功能, 无上下拉
		};
	};
}; // pinctrl 结束